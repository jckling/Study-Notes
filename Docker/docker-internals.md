# 架构

Docker 使用客户端-服务器架构。Docker 客户端与 Docker 守护进程通信，后者负责构建、运行和分发 Docker 容器的繁重工作。

Docker 客户端和守护进程可以在同一个系统上运行，或者可以将 Docker 客户端连接到远程 Docker 守护进程。

Docker 客户端和守护进程使用 REST API，通过 UNIX 套接字或网络接口进行通信。

另一个 Docker 客户端是 Docker Compose，用于处理由一组容器组成的应用程序。

![](https://docs.docker.com/engine/images/architecture.svg)

## Docker 守护进程

Docker 守护进程（`dockerd`）监听 Docker API 请求并管理 Docker 对象，例如镜像、容器、网络和卷。守护进程还可以与其他守护进程通信，以管理 Docker 服务。

## Docker Client

Docker 客户端（`docker`）是许多 Docker 用户与 Docker 交互的主要方式。当运行 `docker run` 等命令时，客户端会将命令发送给 `dockerd`，由其执行这。`docker` 命令使用 Docker API。Docker 客户端可以与多个守护进程通信。

## Docker Desktop

Docker Desktop 是一个易于安装的应用程序，适用于 Mac 或 Windows 环境，用于构建和共享容器化应用程序和微服务。Docker Desktop 包括 Docker 守护进程（`dockerd`）、Docker 客户端 （`docker`）、Docker Compose、Docker Content Trust、Kubernetes 和 Credential Helper。

## Docker 注册服务

Docker 注册服务存储 Docker 镜像。Docker Hub 是一个任何人都可以使用的公共注册服务，并且 Docker 默认配置在 Docker Hub 上查找镜像。用户可以运行自己的私有注册服务。

当运行 `docker pull` 或 `docker run` 命令时，将从配置的注册服务拉取所需的镜像。当运行 `docker push` 命令时，将会把镜像推送到配置的注册服务。

## Docker 对象

使用 Docker 就是在创建和使用镜像、容器、网络、卷、插件和其他对象。

### 镜像

映像是一个只读模板，包含创建 Docker 容器的说明。通常，一个镜像是基于另一个镜像的，并进行了一些额外的定制。例如，可以构建一个基于 ubuntu 镜像的镜像，安装 Apache Web 服务器和用户自己的应用程序，以及应用程序运行所需的配置。

用户可以创建自己的镜像，也可以使用其他人创建并发布在注册服务的镜像。构建自己的镜像需要创建一个 Dockerfile，用简单的语法定义创建和运行镜像所需的步骤。Dockerfile 中的每条指令都会在镜像中创建一个层。当用户更改 Dockerfile 并重构镜像时，仅重构那些被改变的层。与其他虚拟化技术相比，这是使得镜像轻量、小巧和快速的部分原因。

### 容器

容器是镜像的可运行实例。用户可以使用 Docker API 或 CLI 来创建、启动、停止、移动或删除容器。用户可以将容器连接到一个或多个网络，为其附加存储，甚至可以根据容器的当前状态创建新镜像。

默认情况下，容器与其他容器、容器与主机都是相对隔离的。用户可以控制容器的网络、存储或其他底层子系统与其他容器或主机的隔离程度。

容器由其镜像以及用户在创建或启动时提供给的配置选项定义。当容器被移除时，任何未存储在持久存储中的状态更改都会消失。

### `docker run`

以下命令运行 ubuntu 容器，以交互方式连接到本地命令行会话，运行 `/bin/bash`

```bash
$ docker run -i -t ubuntu /bin/bash
```

假设使用默认的注册服务配置，即 Dockerhub
1. 如果本地没有 ubuntu 镜像，Docker 会从注册服务拉取镜像，同 `docker pull ubuntu`
2. Docker 创建新容器，同 `docker container create`
3. Docker 为容器分配读写文件系统，作为它的最后一层
   - 允许正在运行的容器在其本地文件系统中创建或修改文件和目录。
4. 因为没有指定任何网络选项，Docker 创建网络接口，将容器连接到默认网络并分配 IP 地址
   - 默认情况下，容器可以使用主机网络连接到外部网络
5. Docker 启动容器并执行 `/bin/bash`
   - 容器以交互方式运行并连接到终端（`-i` 和 `-t` 标志），可以用键盘提供输入，同时输出被记录到终端
6. 输入 `exit` 终止 `/bin/bash` 命令时，容器会停止但不会被删除，可以重新启动或删除

# 底层实现

Docker 是用 Go 编程语言编写的，并利用 Linux 内核的一些特性来提供其功能。Docker 使用 `namespace` 技术来提供隔离工作区（容器）。运行容器时，Docker 会为该容器创建一组命名空间。

这些命名空间提供了一层隔离。容器的每个方面都在单独的命名空间中运行，其访问权限仅限于该命名空间。

## 命名空间

Docker 引擎在 Linux 上使用以下命名空间
- `pid`（Process ID）：进程
- `net`（Networking）：网络，包括网络设备、IP、路由等
- `ipc`（InterProcess Communication）：IPC 资源，包括信号量、消息队列、共享内存等
- `mnt`（Mount）：文件系统挂载点
- `uts`（Unix Timesharing System）：主机名、域名
- `user`：用户、用户组

## 控制组

Linux 上的 Docker Engine 还依赖于控制组（`cgroups`）技术。控制组允许 Docker 引擎限制容器的可用硬件资源，例如，限制特定容器的可用内存。

## 联合文件系统

UnionFS（Uniton File System）是通过创建层来操作的文件系统，这使其非常轻量和快速。Docker 引擎使用 UnionFS 为容器提供构建层。Docker 引擎可以使用多种 UnionFS 变体，包括 AUFS、btrfs、vfs 和 DeviceMapper 等。

## 容器格式

Docker 引擎将命名空间、控制组和 UnionFS 组合到一个称为容器格式的包装器中。最初使用的是 `LXC`，后续使用 `libcontainer`，目前使用 `runc` 和 `containerd`。

## 网络

虚拟网络设备对（virtual Ethernet, veth）实现不同网络命名空间（network namespace）之间的通信，实际上通过 docker0 网桥连接。

# 安全

## 安全评估

评估 Docker 安全性时，需要考虑四个方面：
- 内核的内在安全性及其对命名空间和 cgroup 的支持
- Docker 守护进程本身的攻击面
- 容器配置文件中的漏洞，无论是默认的，还是由用户自定义的
- 内核的“加固”安全特性，以及它们如何与容器交互

### 内核命名空间

Docker 容器与 LXC 容器非常相似，并且具有相似的安全特性。当运行 `docker run` 启动容器时，Docker 会在后台为容器创建一组命名空间和控制组。

命名空间提供了第一种也是最直接的隔离形式：在一个容器中运行的进程无法看到或影响运行在另一个容器或主机系统中的进程。

每个容器拥有自己的网络堆栈，这意味着一个容器无法获得对另一个容器的套接字或接口的特权访问。当然，如果主机系统进行了相应配置，那么容器可以通过各自的网络接口交互，就像它们可以与外部主机交互一样。当为容器指定公共端口或使用链接（`--link`）时，容器之间的 IP 流量是允许的，它们互 ping，发送/接收 UDP 数据包，并建立 TCP 连接，如果有必要的话，这些也可以被限制。从网络架构的角度来看，给定 Docker 主机上的所有容器都位于桥接接口上，这意味着它们就像通过通用以太网交换机连接的物理机器。

提供内核命名空间和私有网络的代码有多成熟？在内核版本 2.6.15 和 2.6.26 之间引入了内核命名空间，这意味着自 2008 年 7 月（2.6.26 版本发布日期）以来，命名空间代码已经在大量生产系统上进行了测试和审查。命名空间代码的设计和灵感甚至更早，命名空间实际上是为了重新实现 OpenVZ 的功能，以便合并到主流内核中。而 OpenVZ 最初是在 2005 年发布的，所以设计和实现都相当成熟。

### 控制组

控制组是 Linux 容器的另一个关键组成部分，实现资源核算和限制，提供了许多有用的指标，有助于确保每个容器获得其公平的内存、CPU、磁盘 I/O 份额。更重要的是，单个容器无法通过耗尽资源使系统瘫痪。

因此，虽然控制组在阻止一个容器访问或影响另一个容器的数据和进程方面没有发挥作用，但对于抵御一些拒绝服务攻击至关重要。在多租户平台上尤其重要，例如公共和私有 PaaS，即使在某些应用程序出现异常时，也能保证一致的正常运行时间（和性能）。

控制组也已经存在了一段时间，代码始于 2006 年，最初被合并到内核 2.6.24 中。

### Docker 守护进程攻击面

使用 Docker 运行容器（和应用程序）意味着运行 Docker 守护进程。除非选择 Rootless 模式，否则守护进程需要 root 权限。

首先，应该只允许受信任的用户控制 Docker 守护进程。Docker 允许在 Docker 主机和访客容器之间共享目录，并且允许不限制容器的访问权限。这意味着可以启动一个容器，将主机的 `/` 目录映射到其中的 `/host` 目录，并且容器可以不受限地更改主机文件系统。这类似于虚拟化系统允许文件系统资源共享的方式，没有什么能阻止用户与虚拟机共享根文件系统（甚至根块设备）。

这具有很强的安全含义，例如，如果通过 Web 服务器调用 API 配置容器，应该要加倍​​小心地检查参数，确保恶意用户无法传递精心构造的参数，使得 Docker 创建任意容器。

出于这个原因，REST API 端点（由 Docker CLI 用于与 Docker 守护进程通信）在 Docker 0.5.2 中发生变化，现在使用 UNIX 套接字，而不是绑定在 127.0.0.1 上的 TCP 套接字（如果碰巧直接在本地机器上运行 Docker，则容易受到跨站请求伪造攻击）。用户可以使用传统的 UNIX 权限检查来限制对控制套接字的访问。

用户还可以通过 HTTP 公开 REST API，但必须注意上述安全隐患。即使有防火墙限制网络中其他主机对 REST API 端点的访问，该端点仍然可以从容器中访问，并且很容易导致权限提升。因此，必须使用 HTTPS 和证书保护 API 端点。同时建议确保只能从受信任的网络或 VPN 访问。

偏爱 SSH 的用户可以使用 `DOCKER_HOST=ssh://USER@HOST` 或 `ssh -L /path/to/docker.sock:/var/run/docker.sock`。

守护进程也可能受到其他输入的影响，例如，使用 `docker load` 从磁盘加载镜像，或使用 `docker pull` 从网络拉取镜像。从 Docker 1.3.2 开始，镜像在 Linux/Unix 平台上的 `chroot` 子进程中提取。从 Docker 1.10.0 开始，所有镜像都通过其内容的加密校验进行存储和访问，从而限制了攻击者与现有镜像发生碰撞的可能性。

最后，如果在服务器上运行 Docker，建议只在服务器上运行 Docker，并将所有其他服务移动到 Docker 控制的容器中。当然，保留管理工具（可能至少是 SSH 服务器）以及现有的监控/监督进程（例如 `NRPE` 和 `collectd`）是可以的。

### Linux 内核能力机制

默认情况下，Docker 启动的容器功能受限。这意味着什么？

能力机制将二进制 `root/non-root` 二分法转变为细粒度的访问控制系统。进程（如 Web 服务器）如果需要在低于 1024 的端口上绑定，不需要以 root 身份运行：它们可以被授予 `net_bind_service` 能力。还有许多其他功能，几乎适用于所有通常需要 root 权限的特定领域。

这对容器安全意义重大。

典型的服务器以 `root` 身份运行多个进程，包括 SSH 守护进程、`cron` 守护进程、日志守护进程、内核模块、网络配置工具等。容器则不同，因为几乎所有这些任务都由容器周围的基础设施处理：
- SSH 访问通常由运行在 Docker 主机上的单一服务器管理；
- `cron` 在必要时应作为用户进程运行，专门为需要其调度服务的应用程序量身定制，而不是作为平台范围的设施；
- 日志管理通常也交给 Docker，或交给第三方服务，如 Loggly 或 Splunk；
- 硬件管理是无关的，这意味着永远不需要在容器中运行 `udevd` 或等效的守护进程；
- 网络管理发生在容器之外，尽可能地强制分离关注点，这意味着容器永远不需要执行 `ifconfig`、`route` 或 `ip` 命令（除非容器被专门设计为像路由器或防火墙一样工作）。

这意味着在大多数情况下，容器根本不需要“真正的” root 权限。因此，容器能够以较小的能力集运行，即容器中的 root 比真正的 root 拥有更少的权限。例如，它可以：
- 拒绝所有挂载操作；
- 拒绝访问原始套接字（防止数据包欺骗）；
- 拒绝访问某些文件系统操作，例如创建新设备节点、更改文件所有者或更改属性（包括不可变标志）；
- 拒绝模块加载；
- 和许多其他功能。

这意味着即使攻击者设法在容器内提权为 root，也很难造成严重破坏，或提权到主机。

这不会影响常规的 Web 应用，但大大减少了恶意用户的攻击媒介。默认情况下，Docker会丢弃所需功能之外的所有功能，即允许列表而不是拒绝列表。你可以在Linux手册中看到可用能力的完整列表。

运行 Docker 容器的一个主要风险是，给予容器的一组默认功能和挂载可能提供不完整的隔离，无论是独立使用，还是与内核漏洞结合使用时。

Docker 支持添加和删除功能，允许使用非默认配置文件。这可能会使 Docker 通过移除功能变得更安全，或通过增添功能而变得不安全。用户的最佳实践是移除所有能力，除了进程明确需要的能力。

### Docker 内容信任签名验证

可以将 Docker 引擎配置为仅运行签名的镜像。Docker 内容信任的签名验证功能内置于 `dockerd` 二进制文件中。

这是在 Dockerd 配置文件中配置的。

要启用此功能，可以在 `daemon.json` 中配置 trustpinning，只能从被用户指定的根密钥签名的仓库拉取和运行。

这个功能为管理员提供了比以前使用 CLI 强制执行和验证镜像签名更多的洞察力。

### 其他内核安全功能

能力机制只是现代 Linux 内核提供的众多安全功能之一。也可以通过 Docker 来利用现有的知名系统，如 TOMOYO、AppArmor、SELinux、GRSEC 等。

虽然 Docker 目前只启用能力机制，但它不会干扰其他系统，这意味着有许多不同的方法可以加固 Docker 主机。例如：
- 可以用 GRSEC 和 PAX 运行内核，在编译时和运行时都增加了许多安全检查；由于地址随机化等技术，可以抵御许多漏洞。不需要特定于 Docker 的配置，因为这些安全功能适用于系统范围，与容器无关。
- 如果发行版附带 Docker 容器的安全模型模板，可以开箱即用。例如，Docker 官方发布了适用于 AppArmor 的模板，而 Red Hat 为 Docker 提供了 SELinux 策略。这些模板提供了额外的安全网（即使它与能力机制有很大重叠）。
- 可以使用访问控制机制自定义策略。

可以使用第三方工具来加固 Docker 容器，包括特殊的网络拓扑或共享文件系统，也有一些工具可以加固 Docker 容器，而不需要修改 Docker 本身。

从 Docker 1.10 开始，docker 守护进程直接支持用户命名空间，该功能允许将容器中的 root 用户映射到容器外的非 uid-0 用户，这有助于降低容器逃逸的风险。该功能是可用的，但默认情况下未启用。

### 总结

默认情况下，Docker 容器是相当安全的，特别是在容器内以非特权用户身份运行进程。

可以通过启用 AppArmor、SELinux、GRSEC 或其他适当的加固系统来增加额外的安全层。

# 参阅

- [Docker architecture](https://docs.docker.com/get-started/overview/#docker-architecture)
- [底层实现](https://yeasy.gitbook.io/docker_practice/underly)
- [Docker security announcements](https://docs.docker.com/security/)
- [Docker security](https://docs.docker.com/engine/security/)
- [capabilities(7) — Linux manual page](https://man7.org/linux/man-pages/man7/capabilities.7.html)
